<%
include("/jagg/jagg.jag");
include("/jagg/cloud/constants.jag");
include("/modules/pricing/utils.jag");

var zuoraObj = (getConfigInJson()).zuoraConfig;
var user = jagg.getUser().username;
var multiTenantUtils = Packages.org.wso2.carbon.utils.multitenancy.MultitenantUtils;
var tenantDomain = multiTenantUtils.getTenantDomain(user);
var msg, responseObj;
var log = new Log("modules.pricing.manager.jag");
var errorObj = {
    error: true,
    statusCode: 500,
    message: "Internal error. Please retry..."
};

//Generate zuora HPM page parameters
var generateParams = function (workflowReference) {

    try {
        var clientParams = JSON.parse(billingService.prepareParams());
        session.put(ZUORA_SIGNATURE_HASH, billingService.generateHash(clientParams.token, mdAlgorithm));
        clientParams.field_passthrough1 = clientParams.token;
        clientParams.field_passthrough4 = workflowReference;
        if (log.isDebugEnabled()) {
            log.debug("Parameters generated for tenant: " + clientParams.tenantId);
        }
        return {
            error: false,
            statusCode: 200,
            params: clientParams
        }
    } catch (e) {
        log.error("Error while generating params: ");
        log.error(e);
        return errorObj;
    }

};

var getAccountDetails = function () {
    try {
        var accountId = getAccountId();
        var summary = billingService.getAccountSummary(accountId);
        responseObj = {
            error: false,
            message: summary,
            statusCode: 200
        };
        return responseObj;
    } catch (e) {
        msg = "Error while getting account details.. Please retry ";
        responseObj = {
            error: true,
            message: msg,
            statusCode: 500
        };
        log.error("ERROR while getting account details for : " + user + " - " + e.message);
        log.error(e);
        return responseObj;
    }

};
var getAccountId = function () {
    try {
        var userName = user.substring(0, user.indexOf('@'));
        var subscriberData = JSON.parse(apiMonService.getAPISubscriberInfo(userName, tenantDomain));
        var accountNumber = subscriberData.Subscribers.Subscriber.AccountNumber;
        return accountNumber;
    } catch (e) {
        log.error("ERROR while getting the account number for : " + user + " - " + e.message);
        throw e;
    }
};

/*
 Get Usage for a given time line.
 */
var getTenantUsage = function (fromDate, toDate) {

};


var updateContactInfo = function (accountData) {
    try {
        var accountId = getAccountId();
        var url = zuoraObj.serviceUrl + "/v1/accounts/" + accountId;
        var data = {};
        data.billToContact = accountData;
        var response = sendHTTPRequest(url, "PUT", null, data);
        if (response.success === true) {
            responseObj = {
                error: false,
                message: "Your contact information is successfully added",
                statusCode: 200
            };
        } else {
            log.error("Zuora customer account update failed. Error : " + JSON.stringify(response.reasons));
            msg = "Account Update Failed.. Please retry ";
            responseObj = {
                error: true,
                message: msg,
                statusCode: 500
            };
        }
        return responseObj;
    } catch (e) {
        msg = "Account Update Failed.. Please retry ";
        responseObj = {
            error: true,
            message: msg,
            statusCode: 500
        };
        log.error("ERROR while updating contact info for : " + user + " - " + e.message);
        return responseObj;
    }

};


var getCurrencyUsed = function () {
    return zuoraObj.currency;
};



var removePaymentMethod = function (methodId) {
    try {
        var url = zuoraObj.serviceUrl + "/v1/payment-methods/" + methodId;
        var result = sendHTTPRequest(url, "DELETE", null, null);
        responseObj = {
            error: false,
            message: result,
            statusCode: 200
        };
        return responseObj;
    } catch (e) {
        log.error("ERROR while getting payment methods  for : " + user + " - " + e.message);
        log(e);
        msg = "Error while getting payment methods";
        responseObj = {
            error: true,
            message: msg,
            statusCode: 500
        };
        return responseObj;
    }

};

var getAllPaymentMethods = function () {
    try {
        var accountId = getAccountId();
        var zuoraServiceUrl = zuoraObj.serviceUrl;
        var url = zuoraServiceUrl + "/v1/payment-methods/credit-cards/accounts/" + accountId;
        var summary = sendHTTPRequest(url, "GET", null, null);
        responseObj = {
            error: false,
            message: summary,
            statusCode: 200
        };
        return responseObj;
    } catch (e) {
        log.error("ERROR while getting payment methods  for : " + user + " - " + e.message);
        log(e);
        msg = "Error while getting payment methods";
        responseObj = {
            error: true,
            message: msg,
            statusCode: 500
        };
        return responseObj;
    }

};

var updateDefaultPaymentMethod = function (methodId) {
    try {
        var zuoraServiceUrl = zuoraObj.serviceUrl;
        var url = zuoraServiceUrl + "/v1/payment-methods/credit-cards/" + methodId;
        var data = {
            "defaultPaymentMethod": true
        };
        var response = sendHTTPRequest(url, "PUT", null, data);
        responseObj = {
            error: false,
            message: response.success,
            statusCode: 200
        };
        return responseObj;
    } catch (e) {
        log.error("ERROR while while updating the default payment method: " + user + " - " + e.message);
        log(e);
        msg = "Error while updating payment methods";
        responseObj = {
            error: true,
            message: msg,
            statusCode: 500
        };
        return responseObj;
    }

};


/*
 Headers should in following format
 var headers = [
 {
 'name':'apiSecretAccessKey',
 'value' :'password'
 }
 ];
 */
var sendHTTPRequest = function (url, type, headers, data) {
    var username = zuoraObj.user;
    var password = zuoraObj.password;
    var xhr = new XMLHttpRequest();
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.setRequestHeader('apiAccessKeyId', username);
    xhr.setRequestHeader('apiSecretAccessKey', password);

    if (headers != null) {
        for (var i = 0; i < headers.length; i++) {
            xhr.setRequestHeader(headers[i].name, headers[i].value);
        }
    }

    xhr.open(type, url);
    xhr.send(data);

    var response = xhr.responseText;
    if (response != null) {
        return JSON.parse(response);
    } else {
        throw new Error("Response from Zuora cannot be null");
    }
};

var dateTimeFormatter = function (dateTimeFormat) {
    return new Packages.java.text.SimpleDateFormat(dateTimeFormat);
};

var getBillingInvoiceData = function (invoiceId) {
    try {
        var accountId = getAccountId();
        var summary = billingService.getInvoices(accountId);
        var invoiceObj = JSON.parse(summary);
        var invoices = invoiceObj.invoices;
        for (var index = 0; index < invoices.length; index++) {
            if (invoiceId == invoices[index].id) {
                var invoiceItems = invoices[index].invoiceItems;

                var invoiceData = {};

                invoiceData["accountName"] = invoices[index].accountName;
                invoiceData["invoiceDate"] = invoices[index].invoiceDate;
                invoiceData["invoiceNumber"] = invoices[index].invoiceNumber;
                invoiceData["amount"] = invoices[index].amount;
                invoiceData["invoiceItems"] = [];

                for (var i = 0; i < invoiceItems.length; i++) {
                    var item = {};
                    var invoiceItem = invoiceItems[i];
                    if (invoiceItem.chargeName == MONTHLY_SUBSCRIPTION_CHARGE_NAME) {
                        item["chargeName"] = invoiceItem.chargeName;
                        item["amount"] = invoiceItem.chargeAmount;
                        item["servicePeriod"] = invoiceItem.serviceStartDate + " to " + invoiceItem.serviceEndDate;
                        item["chargeDate"] = invoices[index].invoiceDate;
                        //if next invoice item is not in the next billing cycle
                        if ((i + 1) < invoiceItems.length && invoiceItems[i + 1].chargeName == DISCOUNT_CHARGE_NAME) {
                            item["discount"] = invoiceItems[i + 1].chargeAmount;
                        }
                        else {
                            item["discount"] = 0.0;
                        }
                    }
                    else {
                        item["chargeName"] = invoiceItem.chargeName;
                        item["amount"] = invoiceItem.chargeAmount;
                        item["servicePeriod"] = invoiceItem.serviceStartDate + " to " + invoiceItem.serviceEndDate;
                        item["chargeDate"] = invoices[index].invoiceDate;
                        item["discount"] = 0.0;
                    }
                    invoiceData["invoiceItems"].push(item);
                }
                responseObj = {
                    error: false,
                    message: invoiceData,
                    statusCode: 200
                };
                return responseObj;
            }
        }
    } catch (e) {

        msg = "Error while updating payment methods";
        responseObj = {
            error: true,
            message: msg,
            statusCode: 500
        };
        log.error("ERROR while getting invoice data for : " + user + " - " + e.message);
        return responseObj;
    }
};
//API monetization enabled status
var isMonetizationEnabled = function (tenantDomain) {
    try {
        var monetizationStatus = apiMonService.isMonetizationEnabled(tenantDomain);
        return {
            error: false,
            statusCode: 200,
            monetizationEnabled: monetizationStatus
        }
    } catch (e) {
        log.error("Error while checking the monetization status for tenant: " + tenantDomain);
        log.error(e);
        return errorObj;
    }

};

//Create billing account with the subscription
var createAccount = function (accountData, metaData, workflowRefData) {

    var ratePlanId, errorMsg;
    var username = jagg.getUser().username;
    var multiTenantUtils = Packages.org.wso2.carbon.utils.multitenancy.MultitenantUtils;
    var tenantDomain = multiTenantUtils.getTenantDomain(username);

    if (!validatePassThroughHash(metaData.field_passthrough1)) {
        errorMsg = "Invalid token. ";
        log.error(errorMsg + ". Hash value mismatch. ");
        return {
            error: true,
            statusCode: 500,
            message: errorMsg + " Please retry..."
        };
    }

    if (workflowRefData == null || "".equals(workflowRefData)) {
        errorMsg = "Workflow refId is invalid. it should be neither null nor empty";
        log.error(errorMsg);
        return {
            error: true,
            statusCode: 500,
            message: errorMsg
        };
    }

    //base64 decode and decrypt the workflow data
    var apiData = decryptWorkflowData(workflowRefData);
    try {
        ratePlanId = apiMonService.getRatePlanId(tenantDomain, apiData.ratePlanName);
        if (ratePlanId == null || "".equals(ratePlanId)) {
            errorMsg = "Rate plan invalid. it should be neither null nor empty";
            log.error(errorMsg);
            return {
                error: true,
                statusCode: 500,
                message: errorMsg
            };
        }
    } catch (e) {
        log.error("Error while getting subscribed rate plan id.");
        log.error(e);
        return {
            error: true,
            statusCode: 500,
            message: e.message
        };
    }

    try {
        var effectiveDate = new Packages.java.util.Date();
        var data = populateAccountInfo(accountData, metaData, effectiveDate, ratePlanId);
        var response = billingService.createChildAccount(tenantDomain, stringify(data));

        var responseObj = JSON.parse(response);
        var createChildResObj = responseObj.createChildResponse;
        var addParentObj = responseObj.addParentResponse;
        var updateSubscriberResult, addSubscriptionResult;

        if (createChildResObj.success) {
            updateSubscriberResult = apiMonService.updateAPISubscriberInfo(username, tenantDomain, false,
                    createChildResObj.accountNumber);
            if (updateSubscriberResult) {
                apiData.subscriptionId = createChildResObj.subscriptionId;
                apiData.ratePlanId = ratePlanId;
                var sqlDateFormat = dateTimeFormatter(MYSQL_DATETIME_FORMAT);
                var formattedEffectiveDate = sqlDateFormat.format(effectiveDate);
                addSubscriptionResult = apiMonService.addSubscriptionInformation(tenantDomain, createChildResObj
                        .accountNumber, stringify(apiData), formattedEffectiveDate);
                if (!addSubscriptionResult) {
                    log.error("Error while updating subscription information. subscription information update failed. "
                            + "account name: " + data.name + " account number: " + createChildResObj.accountNumber + "for tenant:"
                            + tenantDomain);
                    //Send error notification. Roll back won't happen since the subscriptions has been already paid
                    return {
                        error: true,
                        statusCode: 500,
                        message: "Subscription unsuccessful. Since the payment has already been processed, please contact" +
                        "support."
                    };
                }
            } else {
                log.error("Error while updating subscriber information. Account update failed. Account: " + data.name
                        + " will get deleted. Please issue a refund for " + data.name + " in tenant: " + tenantDomain);
                //Send notification the cloud and the publisher saying to issue a refund. account will not get deleted.

                //var deleteResponse = JSON.parse(billingService.deleteAccount(data.name));
                /*if (deleteResponse.successSpecified && deleteResponse.success) {
                 //Send error notification to cloud to issue a refund
                 return {
                 error: true,
                 statusCode: 500,
                 message: "Subscription unsuccessful. You'll get a refund. if not please contact support."
                 };
                 } else {
                 return {
                 error: true,
                 statusCode: 500,
                 message: "Subscription unsuccessful. your payment has already processed. Please contact support."
                 };
                 }*/
            }

            if (addParentObj.success == null || !addParentObj.success) {
                log.error("Adding parent failed for child." + " Tenant: " + tenantDomain + " For monetizing. Reasons: "
                        + stringify(createChildResObj.reasons));
            }
        } else {
            errorMsg = "Billing account creation failed.";
            log.error(errorMsg + " Tenant: " + tenantDomain + " For monetizing. Reasons: " + stringify
                    (createChildResObj.reasons));
            return {
                error: true,
                statusCode: 500,
                message: errorMsg + "Please Retry..."
            };
        }

        var modWorkflow = jagg.module("workflow");
        var workflowStatus;
        var workflowDesc;
        var workflowReference = apiData.workflowRefId;
        if (updateSubscriberResult && addSubscriptionResult) {
            workflowStatus = "APPROVED";
            workflowDesc = "subscription successful";
            return modWorkflow.resumeWorkflow(workflowReference, workflowStatus, workflowDesc);
        } else {
            workflowStatus = "REJECTED";
            workflowDesc = "subscription unsuccessful";
            modWorkflow.resumeWorkflow(workflowReference, workflowStatus, workflowDesc);
            //Send error notification. Roll back won't happen since the subscriptions has been already paid
            return {
                error: true,
                statusCode: 500,
                message: errorMsg + "Subscription failed. API will not be activated." +
                "Since the payment has already been processed, please contact support."
            };
        }


    } catch (e) {
        log.error("Child account creation failure. ");
        log.error(e);
        return {
            error: true,
            statusCode: 500,
            message: e.message
        };
    }
};
%>